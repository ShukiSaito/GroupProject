// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickTypeSalary;
//
//    var playerSalary = PlayerSalary.FromJson(jsonString);

namespace QuickTypeSalary
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class PlayerSalary
    {
        [JsonProperty("SlateID")]
        public long SlateId { get; set; }

        [JsonProperty("Operator")]
        public Operator Operator { get; set; }

        [JsonProperty("OperatorSlateID")]
        public long OperatorSlateId { get; set; }

        [JsonProperty("OperatorName")]
        public string OperatorName { get; set; }

        [JsonProperty("OperatorDay")]
        public DateTimeOffset OperatorDay { get; set; }

        [JsonProperty("OperatorStartTime")]
        public DateTimeOffset OperatorStartTime { get; set; }

        [JsonProperty("NumberOfGames")]
        public object NumberOfGames { get; set; }

        [JsonProperty("IsMultiDaySlate")]
        public bool IsMultiDaySlate { get; set; }

        [JsonProperty("RemovedByOperator")]
        public bool RemovedByOperator { get; set; }

        [JsonProperty("OperatorGameType")]
        public OperatorGameType OperatorGameType { get; set; }

        [JsonProperty("SalaryCap")]
        public long SalaryCap { get; set; }

        [JsonProperty("CompetitionId")]
        public long CompetitionId { get; set; }

        [JsonProperty("SlateRosterSlots")]
        public SlateRosterSlot[] SlateRosterSlots { get; set; }

        [JsonProperty("DfsSlateGames")]
        public DfsSlateGame[] DfsSlateGames { get; set; }

        [JsonProperty("DfsSlatePlayers")]
        public DfsSlatePlayer[] DfsSlatePlayers { get; set; }
    }

    public partial class DfsSlateGame
    {
        [JsonProperty("SlateGameID")]
        public long SlateGameId { get; set; }

        [JsonProperty("SlateID")]
        public long SlateId { get; set; }

        [JsonProperty("GameID")]
        public long? GameId { get; set; }

        [JsonProperty("OperatorGameID")]
        public long OperatorGameId { get; set; }

        [JsonProperty("RemovedByOperator")]
        public bool RemovedByOperator { get; set; }

        [JsonProperty("Game")]
        public Game Game { get; set; }
    }

    public partial class Game
    {
        [JsonProperty("GameId")]
        public long GameId { get; set; }

        [JsonProperty("RoundId")]
        public long RoundId { get; set; }

        [JsonProperty("Season")]
        public long Season { get; set; }

        [JsonProperty("SeasonType")]
        public long SeasonType { get; set; }

        [JsonProperty("Group")]
        public object Group { get; set; }

        [JsonProperty("AwayTeamId")]
        public long AwayTeamId { get; set; }

        [JsonProperty("HomeTeamId")]
        public long HomeTeamId { get; set; }

        [JsonProperty("VenueId")]
        public long VenueId { get; set; }

        [JsonProperty("Day")]
        public DateTimeOffset Day { get; set; }

        [JsonProperty("DateTime")]
        public DateTimeOffset DateTime { get; set; }

        [JsonProperty("Status")]
        public Status Status { get; set; }

        [JsonProperty("Week")]
        public long? Week { get; set; }

        [JsonProperty("Period")]
        public Period Period { get; set; }

        [JsonProperty("Clock")]
        public long? Clock { get; set; }

        [JsonProperty("Winner")]
        public Winner Winner { get; set; }

        [JsonProperty("VenueType")]
        public VenueType VenueType { get; set; }

        [JsonProperty("AwayTeamKey")]
        public Team AwayTeamKey { get; set; }

        [JsonProperty("AwayTeamName")]
        public string AwayTeamName { get; set; }

        [JsonProperty("AwayTeamCountryCode")]
        public TeamCountryCode AwayTeamCountryCode { get; set; }

        [JsonProperty("AwayTeamScore")]
        public long? AwayTeamScore { get; set; }

        [JsonProperty("AwayTeamScorePeriod1")]
        public long? AwayTeamScorePeriod1 { get; set; }

        [JsonProperty("AwayTeamScorePeriod2")]
        public long? AwayTeamScorePeriod2 { get; set; }

        [JsonProperty("AwayTeamScoreExtraTime")]
        public object AwayTeamScoreExtraTime { get; set; }

        [JsonProperty("AwayTeamScorePenalty")]
        public object AwayTeamScorePenalty { get; set; }

        [JsonProperty("HomeTeamKey")]
        public Team HomeTeamKey { get; set; }

        [JsonProperty("HomeTeamName")]
        public string HomeTeamName { get; set; }

        [JsonProperty("HomeTeamCountryCode")]
        public TeamCountryCode HomeTeamCountryCode { get; set; }

        [JsonProperty("HomeTeamScore")]
        public long? HomeTeamScore { get; set; }

        [JsonProperty("HomeTeamScorePeriod1")]
        public long? HomeTeamScorePeriod1 { get; set; }

        [JsonProperty("HomeTeamScorePeriod2")]
        public long? HomeTeamScorePeriod2 { get; set; }

        [JsonProperty("HomeTeamScoreExtraTime")]
        public object HomeTeamScoreExtraTime { get; set; }

        [JsonProperty("HomeTeamScorePenalty")]
        public object HomeTeamScorePenalty { get; set; }

        [JsonProperty("HomeTeamMoneyLine")]
        public long? HomeTeamMoneyLine { get; set; }

        [JsonProperty("AwayTeamMoneyLine")]
        public long? AwayTeamMoneyLine { get; set; }

        [JsonProperty("DrawMoneyLine")]
        public long? DrawMoneyLine { get; set; }

        [JsonProperty("PointSpread")]
        public double? PointSpread { get; set; }

        [JsonProperty("HomeTeamPointSpreadPayout")]
        public long? HomeTeamPointSpreadPayout { get; set; }

        [JsonProperty("AwayTeamPointSpreadPayout")]
        public long? AwayTeamPointSpreadPayout { get; set; }

        [JsonProperty("OverUnder")]
        public double? OverUnder { get; set; }

        [JsonProperty("OverPayout")]
        public long? OverPayout { get; set; }

        [JsonProperty("UnderPayout")]
        public long? UnderPayout { get; set; }

        [JsonProperty("Attendance")]
        public long? Attendance { get; set; }

        [JsonProperty("Updated")]
        public DateTimeOffset Updated { get; set; }

        [JsonProperty("UpdatedUtc")]
        public DateTimeOffset UpdatedUtc { get; set; }

        [JsonProperty("GlobalGameId")]
        public long GlobalGameId { get; set; }

        [JsonProperty("GlobalAwayTeamId")]
        public long GlobalAwayTeamId { get; set; }

        [JsonProperty("GlobalHomeTeamId")]
        public long GlobalHomeTeamId { get; set; }

        [JsonProperty("ClockExtra")]
        public object ClockExtra { get; set; }

        [JsonProperty("ClockDisplay")]
        public string ClockDisplay { get; set; }

        [JsonProperty("IsClosed")]
        public bool IsClosed { get; set; }

        [JsonProperty("HomeTeamFormation")]
        public HomeTeamFormation? HomeTeamFormation { get; set; }

        [JsonProperty("AwayTeamFormation")]
        public string AwayTeamFormation { get; set; }

        [JsonProperty("PlayoffAggregateScore")]
        public object PlayoffAggregateScore { get; set; }
    }

    public partial class DfsSlatePlayer
    {
        [JsonProperty("SlatePlayerID")]
        public long SlatePlayerId { get; set; }

        [JsonProperty("SlateID")]
        public long SlateId { get; set; }

        [JsonProperty("SlateGameID")]
        public long? SlateGameId { get; set; }

        [JsonProperty("PlayerID")]
        public long PlayerId { get; set; }

        [JsonProperty("PlayerGameProjectionStatID")]
        public long? PlayerGameProjectionStatId { get; set; }

        [JsonProperty("OperatorPlayerID")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long OperatorPlayerId { get; set; }

        [JsonProperty("OperatorSlatePlayerID")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long OperatorSlatePlayerId { get; set; }

        [JsonProperty("OperatorPlayerName")]
        public string OperatorPlayerName { get; set; }

        [JsonProperty("OperatorPosition")]
        public SlateRosterSlot OperatorPosition { get; set; }

        [JsonProperty("OperatorSalary")]
        public long OperatorSalary { get; set; }

        [JsonProperty("RemovedByOperator")]
        public bool RemovedByOperator { get; set; }

        [JsonProperty("Team")]
        public Team Team { get; set; }

        [JsonProperty("TeamID")]
        public long TeamId { get; set; }

        [JsonProperty("OperatorRosterSlots")]
        public SlateRosterSlot[] OperatorRosterSlots { get; set; }
    }

    public enum TeamCountryCode { Eng, Usa };

    public enum Team { Ars, Ast, Bha, Bor, Bur, Cfc, Cry, Eve, Ful, Laf, Lee, Lei, Liv, Mnc, Mnu, New, Nor, Psg, Rma, Rsl, She, Sot, Tot, Wat, Wba, Whu, Wol };

    public enum HomeTeamFormation { The3142, The3421, The343, The352, The4141, The4231, The433, The4411, The442, The442Diamond, The451, The532, The541 };

    public enum Period { Regular };

    public enum Status { Final, InProgress, Scheduled };

    public enum VenueType { HomeAway };

    public enum Winner { Scrambled };

    public enum SlateRosterSlot { Cpt, D, F, Flex, Gk, M, MF, Util };

    public enum Operator { Draftkings };

    public enum OperatorGameType { Classic, Showdown };

    public partial class PlayerSalary
    {
        public static PlayerSalary[] FromJson(string json) => JsonConvert.DeserializeObject<PlayerSalary[]>(json, QuickTypeSalary.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this PlayerSalary[] self) => JsonConvert.SerializeObject(self, QuickTypeSalary.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TeamCountryCodeConverter.Singleton,
                TeamConverter.Singleton,
                HomeTeamFormationConverter.Singleton,
                PeriodConverter.Singleton,
                StatusConverter.Singleton,
                VenueTypeConverter.Singleton,
                WinnerConverter.Singleton,
                SlateRosterSlotConverter.Singleton,
                OperatorConverter.Singleton,
                OperatorGameTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TeamCountryCodeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TeamCountryCode) || t == typeof(TeamCountryCode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ENG":
                    return TeamCountryCode.Eng;
                case "USA":
                    return TeamCountryCode.Usa;
            }
            throw new Exception("Cannot unmarshal type TeamCountryCode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TeamCountryCode)untypedValue;
            switch (value)
            {
                case TeamCountryCode.Eng:
                    serializer.Serialize(writer, "ENG");
                    return;
                case TeamCountryCode.Usa:
                    serializer.Serialize(writer, "USA");
                    return;
            }
            throw new Exception("Cannot marshal type TeamCountryCode");
        }

        public static readonly TeamCountryCodeConverter Singleton = new TeamCountryCodeConverter();
    }

    internal class TeamConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Team) || t == typeof(Team?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ARS":
                    return Team.Ars;
                case "AST":
                    return Team.Ast;
                case "BHA":
                    return Team.Bha;
                case "BOR":
                    return Team.Bor;
                case "BUR":
                    return Team.Bur;
                case "CFC":
                    return Team.Cfc;
                case "CRY":
                    return Team.Cry;
                case "EVE":
                    return Team.Eve;
                case "FUL":
                    return Team.Ful;
                case "LAF":
                    return Team.Laf;
                case "LEE":
                    return Team.Lee;
                case "LEI":
                    return Team.Lei;
                case "LIV":
                    return Team.Liv;
                case "MNC":
                    return Team.Mnc;
                case "MNU":
                    return Team.Mnu;
                case "NEW":
                    return Team.New;
                case "NOR":
                    return Team.Nor;
                case "PSG":
                    return Team.Psg;
                case "RMA":
                    return Team.Rma;
                case "RSL":
                    return Team.Rsl;
                case "SHE":
                    return Team.She;
                case "SOT":
                    return Team.Sot;
                case "TOT":
                    return Team.Tot;
                case "WAT":
                    return Team.Wat;
                case "WBA":
                    return Team.Wba;
                case "WHU":
                    return Team.Whu;
                case "WOL":
                    return Team.Wol;
            }
            throw new Exception("Cannot unmarshal type Team");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Team)untypedValue;
            switch (value)
            {
                case Team.Ars:
                    serializer.Serialize(writer, "ARS");
                    return;
                case Team.Ast:
                    serializer.Serialize(writer, "AST");
                    return;
                case Team.Bha:
                    serializer.Serialize(writer, "BHA");
                    return;
                case Team.Bor:
                    serializer.Serialize(writer, "BOR");
                    return;
                case Team.Bur:
                    serializer.Serialize(writer, "BUR");
                    return;
                case Team.Cfc:
                    serializer.Serialize(writer, "CFC");
                    return;
                case Team.Cry:
                    serializer.Serialize(writer, "CRY");
                    return;
                case Team.Eve:
                    serializer.Serialize(writer, "EVE");
                    return;
                case Team.Ful:
                    serializer.Serialize(writer, "FUL");
                    return;
                case Team.Laf:
                    serializer.Serialize(writer, "LAF");
                    return;
                case Team.Lee:
                    serializer.Serialize(writer, "LEE");
                    return;
                case Team.Lei:
                    serializer.Serialize(writer, "LEI");
                    return;
                case Team.Liv:
                    serializer.Serialize(writer, "LIV");
                    return;
                case Team.Mnc:
                    serializer.Serialize(writer, "MNC");
                    return;
                case Team.Mnu:
                    serializer.Serialize(writer, "MNU");
                    return;
                case Team.New:
                    serializer.Serialize(writer, "NEW");
                    return;
                case Team.Nor:
                    serializer.Serialize(writer, "NOR");
                    return;
                case Team.Psg:
                    serializer.Serialize(writer, "PSG");
                    return;
                case Team.Rma:
                    serializer.Serialize(writer, "RMA");
                    return;
                case Team.Rsl:
                    serializer.Serialize(writer, "RSL");
                    return;
                case Team.She:
                    serializer.Serialize(writer, "SHE");
                    return;
                case Team.Sot:
                    serializer.Serialize(writer, "SOT");
                    return;
                case Team.Tot:
                    serializer.Serialize(writer, "TOT");
                    return;
                case Team.Wat:
                    serializer.Serialize(writer, "WAT");
                    return;
                case Team.Wba:
                    serializer.Serialize(writer, "WBA");
                    return;
                case Team.Whu:
                    serializer.Serialize(writer, "WHU");
                    return;
                case Team.Wol:
                    serializer.Serialize(writer, "WOL");
                    return;
            }
            throw new Exception("Cannot marshal type Team");
        }

        public static readonly TeamConverter Singleton = new TeamConverter();
    }

    internal class HomeTeamFormationConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HomeTeamFormation) || t == typeof(HomeTeamFormation?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "3-1-4-2":
                    return HomeTeamFormation.The3142;
                case "3-4-2-1":
                    return HomeTeamFormation.The3421;
                case "3-4-3":
                    return HomeTeamFormation.The343;
                case "3-5-2":
                    return HomeTeamFormation.The352;
                case "4-1-4-1":
                    return HomeTeamFormation.The4141;
                case "4-2-3-1":
                    return HomeTeamFormation.The4231;
                case "4-3-3":
                    return HomeTeamFormation.The433;
                case "4-4-1-1":
                    return HomeTeamFormation.The4411;
                case "4-4-2":
                    return HomeTeamFormation.The442;
                case "4-4-2 diamond":
                    return HomeTeamFormation.The442Diamond;
                case "4-5-1":
                    return HomeTeamFormation.The451;
                case "5-3-2":
                    return HomeTeamFormation.The532;
                case "5-4-1":
                    return HomeTeamFormation.The541;
            }
            throw new Exception("Cannot unmarshal type HomeTeamFormation");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HomeTeamFormation)untypedValue;
            switch (value)
            {
                case HomeTeamFormation.The3142:
                    serializer.Serialize(writer, "3-1-4-2");
                    return;
                case HomeTeamFormation.The3421:
                    serializer.Serialize(writer, "3-4-2-1");
                    return;
                case HomeTeamFormation.The343:
                    serializer.Serialize(writer, "3-4-3");
                    return;
                case HomeTeamFormation.The352:
                    serializer.Serialize(writer, "3-5-2");
                    return;
                case HomeTeamFormation.The4141:
                    serializer.Serialize(writer, "4-1-4-1");
                    return;
                case HomeTeamFormation.The4231:
                    serializer.Serialize(writer, "4-2-3-1");
                    return;
                case HomeTeamFormation.The433:
                    serializer.Serialize(writer, "4-3-3");
                    return;
                case HomeTeamFormation.The4411:
                    serializer.Serialize(writer, "4-4-1-1");
                    return;
                case HomeTeamFormation.The442:
                    serializer.Serialize(writer, "4-4-2");
                    return;
                case HomeTeamFormation.The442Diamond:
                    serializer.Serialize(writer, "4-4-2 diamond");
                    return;
                case HomeTeamFormation.The451:
                    serializer.Serialize(writer, "4-5-1");
                    return;
                case HomeTeamFormation.The532:
                    serializer.Serialize(writer, "5-3-2");
                    return;
                case HomeTeamFormation.The541:
                    serializer.Serialize(writer, "5-4-1");
                    return;
            }
            throw new Exception("Cannot marshal type HomeTeamFormation");
        }

        public static readonly HomeTeamFormationConverter Singleton = new HomeTeamFormationConverter();
    }

    internal class PeriodConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Period) || t == typeof(Period?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Regular")
            {
                return Period.Regular;
            }
            throw new Exception("Cannot unmarshal type Period");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Period)untypedValue;
            if (value == Period.Regular)
            {
                serializer.Serialize(writer, "Regular");
                return;
            }
            throw new Exception("Cannot marshal type Period");
        }

        public static readonly PeriodConverter Singleton = new PeriodConverter();
    }

    internal class StatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Status) || t == typeof(Status?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Final":
                    return Status.Final;
                case "InProgress":
                    return Status.InProgress;
                case "Scheduled":
                    return Status.Scheduled;
            }
            throw new Exception("Cannot unmarshal type Status");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Status)untypedValue;
            switch (value)
            {
                case Status.Final:
                    serializer.Serialize(writer, "Final");
                    return;
                case Status.InProgress:
                    serializer.Serialize(writer, "InProgress");
                    return;
                case Status.Scheduled:
                    serializer.Serialize(writer, "Scheduled");
                    return;
            }
            throw new Exception("Cannot marshal type Status");
        }

        public static readonly StatusConverter Singleton = new StatusConverter();
    }

    internal class VenueTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VenueType) || t == typeof(VenueType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Home Away")
            {
                return VenueType.HomeAway;
            }
            throw new Exception("Cannot unmarshal type VenueType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VenueType)untypedValue;
            if (value == VenueType.HomeAway)
            {
                serializer.Serialize(writer, "Home Away");
                return;
            }
            throw new Exception("Cannot marshal type VenueType");
        }

        public static readonly VenueTypeConverter Singleton = new VenueTypeConverter();
    }

    internal class WinnerConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Winner) || t == typeof(Winner?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Scrambled")
            {
                return Winner.Scrambled;
            }
            throw new Exception("Cannot unmarshal type Winner");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Winner)untypedValue;
            if (value == Winner.Scrambled)
            {
                serializer.Serialize(writer, "Scrambled");
                return;
            }
            throw new Exception("Cannot marshal type Winner");
        }

        public static readonly WinnerConverter Singleton = new WinnerConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class SlateRosterSlotConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SlateRosterSlot) || t == typeof(SlateRosterSlot?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CPT":
                    return SlateRosterSlot.Cpt;
                case "D":
                    return SlateRosterSlot.D;
                case "F":
                    return SlateRosterSlot.F;
                case "FLEX":
                    return SlateRosterSlot.Flex;
                case "GK":
                    return SlateRosterSlot.Gk;
                case "M":
                    return SlateRosterSlot.M;
                case "M/F":
                    return SlateRosterSlot.MF;
                case "UTIL":
                    return SlateRosterSlot.Util;
            }
            throw new Exception("Cannot unmarshal type SlateRosterSlot");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SlateRosterSlot)untypedValue;
            switch (value)
            {
                case SlateRosterSlot.Cpt:
                    serializer.Serialize(writer, "CPT");
                    return;
                case SlateRosterSlot.D:
                    serializer.Serialize(writer, "D");
                    return;
                case SlateRosterSlot.F:
                    serializer.Serialize(writer, "F");
                    return;
                case SlateRosterSlot.Flex:
                    serializer.Serialize(writer, "FLEX");
                    return;
                case SlateRosterSlot.Gk:
                    serializer.Serialize(writer, "GK");
                    return;
                case SlateRosterSlot.M:
                    serializer.Serialize(writer, "M");
                    return;
                case SlateRosterSlot.MF:
                    serializer.Serialize(writer, "M/F");
                    return;
                case SlateRosterSlot.Util:
                    serializer.Serialize(writer, "UTIL");
                    return;
            }
            throw new Exception("Cannot marshal type SlateRosterSlot");
        }

        public static readonly SlateRosterSlotConverter Singleton = new SlateRosterSlotConverter();
    }

    internal class OperatorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Operator) || t == typeof(Operator?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Draftkings")
            {
                return Operator.Draftkings;
            }
            throw new Exception("Cannot unmarshal type Operator");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Operator)untypedValue;
            if (value == Operator.Draftkings)
            {
                serializer.Serialize(writer, "Draftkings");
                return;
            }
            throw new Exception("Cannot marshal type Operator");
        }

        public static readonly OperatorConverter Singleton = new OperatorConverter();
    }

    internal class OperatorGameTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OperatorGameType) || t == typeof(OperatorGameType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Classic":
                    return OperatorGameType.Classic;
                case "Showdown":
                    return OperatorGameType.Showdown;
            }
            throw new Exception("Cannot unmarshal type OperatorGameType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OperatorGameType)untypedValue;
            switch (value)
            {
                case OperatorGameType.Classic:
                    serializer.Serialize(writer, "Classic");
                    return;
                case OperatorGameType.Showdown:
                    serializer.Serialize(writer, "Showdown");
                    return;
            }
            throw new Exception("Cannot marshal type OperatorGameType");
        }

        public static readonly OperatorGameTypeConverter Singleton = new OperatorGameTypeConverter();
    }
}
