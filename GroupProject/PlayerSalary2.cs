// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickTypeSalary2;
//
//    var playerSalary2 = PlayerSalary2.FromJson(jsonString);

namespace QuickTypeSalary2
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class PlayerSalary2
    {
        [JsonProperty("StatId")]
        public long StatId { get; set; }

        [JsonProperty("SeasonType")]
        public long SeasonType { get; set; }

        [JsonProperty("Season")]
        public long Season { get; set; }

        [JsonProperty("RoundId")]
        public long RoundId { get; set; }

        [JsonProperty("TeamId")]
        public long TeamId { get; set; }

        [JsonProperty("PlayerId")]
        public long PlayerId { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("ShortName")]
        public string ShortName { get; set; }

        [JsonProperty("Team")]
        public Opponent Team { get; set; }

        [JsonProperty("PositionCategory")]
        public Position PositionCategory { get; set; }

        [JsonProperty("Position")]
        public Position Position { get; set; }

        [JsonProperty("Jersey")]
        public object Jersey { get; set; }

        [JsonProperty("Started")]
        public long Started { get; set; }

        [JsonProperty("Captain")]
        public bool Captain { get; set; }

        [JsonProperty("Suspension")]
        public bool Suspension { get; set; }

        [JsonProperty("SuspensionReason")]
        public string SuspensionReason { get; set; }

        [JsonProperty("FanDuelSalary")]
        public object FanDuelSalary { get; set; }

        [JsonProperty("DraftKingsSalary")]
        public long? DraftKingsSalary { get; set; }

        [JsonProperty("YahooSalary")]
        public object YahooSalary { get; set; }

        [JsonProperty("MondogoalSalary")]
        public object MondogoalSalary { get; set; }

        [JsonProperty("FanDuelPosition")]
        public DraftKingsPosition FanDuelPosition { get; set; }

        [JsonProperty("DraftKingsPosition")]
        public DraftKingsPosition DraftKingsPosition { get; set; }

        [JsonProperty("YahooPosition")]
        public DraftKingsPosition YahooPosition { get; set; }

        [JsonProperty("MondogoalPosition")]
        public DraftKingsPosition MondogoalPosition { get; set; }

        [JsonProperty("InjuryStatus")]
        public DraftKingsPosition InjuryStatus { get; set; }

        [JsonProperty("InjuryBodyPart")]
        public DraftKingsPosition InjuryBodyPart { get; set; }

        [JsonProperty("InjuryNotes")]
        public DraftKingsPosition InjuryNotes { get; set; }

        [JsonProperty("InjuryStartDate")]
        public DateTimeOffset? InjuryStartDate { get; set; }

        [JsonProperty("GlobalTeamId")]
        public long GlobalTeamId { get; set; }

        [JsonProperty("GameId")]
        public long GameId { get; set; }

        [JsonProperty("OpponentId")]
        public long OpponentId { get; set; }

        [JsonProperty("Opponent")]
        public Opponent Opponent { get; set; }

        [JsonProperty("Day")]
        public DateTimeOffset Day { get; set; }

        [JsonProperty("DateTime")]
        public DateTimeOffset DateTime { get; set; }

        [JsonProperty("HomeOrAway")]
        public HomeOrAway HomeOrAway { get; set; }

        [JsonProperty("IsGameOver")]
        public bool IsGameOver { get; set; }

        [JsonProperty("GlobalGameId")]
        public long GlobalGameId { get; set; }

        [JsonProperty("GlobalOpponentId")]
        public long GlobalOpponentId { get; set; }

        [JsonProperty("Updated")]
        public DateTimeOffset Updated { get; set; }

        [JsonProperty("UpdatedUtc")]
        public DateTimeOffset UpdatedUtc { get; set; }

        [JsonProperty("Games")]
        public long Games { get; set; }

        [JsonProperty("FantasyPoints")]
        public double FantasyPoints { get; set; }

        [JsonProperty("FantasyPointsFanDuel")]
        public object FantasyPointsFanDuel { get; set; }

        [JsonProperty("FantasyPointsDraftKings")]
        public double FantasyPointsDraftKings { get; set; }

        [JsonProperty("FantasyPointsYahoo")]
        public object FantasyPointsYahoo { get; set; }

        [JsonProperty("FantasyPointsMondogoal")]
        public double FantasyPointsMondogoal { get; set; }

        [JsonProperty("Minutes")]
        public double Minutes { get; set; }

        [JsonProperty("Goals")]
        public double Goals { get; set; }

        [JsonProperty("Assists")]
        public long Assists { get; set; }

        [JsonProperty("Shots")]
        public double Shots { get; set; }

        [JsonProperty("ShotsOnGoal")]
        public double ShotsOnGoal { get; set; }

        [JsonProperty("YellowCards")]
        public double YellowCards { get; set; }

        [JsonProperty("RedCards")]
        public long RedCards { get; set; }

        [JsonProperty("YellowRedCards")]
        public long YellowRedCards { get; set; }

        [JsonProperty("Crosses")]
        public double Crosses { get; set; }

        [JsonProperty("TacklesWon")]
        public double TacklesWon { get; set; }

        [JsonProperty("Interceptions")]
        public double Interceptions { get; set; }

        [JsonProperty("OwnGoals")]
        public long OwnGoals { get; set; }

        [JsonProperty("Fouls")]
        public double Fouls { get; set; }

        [JsonProperty("Fouled")]
        public double Fouled { get; set; }

        [JsonProperty("Offsides")]
        public long Offsides { get; set; }

        [JsonProperty("Passes")]
        public long Passes { get; set; }

        [JsonProperty("PassesCompleted")]
        public double PassesCompleted { get; set; }

        [JsonProperty("LastManTackle")]
        public long LastManTackle { get; set; }

        [JsonProperty("CornersWon")]
        public long CornersWon { get; set; }

        [JsonProperty("BlockedShots")]
        public long BlockedShots { get; set; }

        [JsonProperty("Touches")]
        public long Touches { get; set; }

        [JsonProperty("DefenderCleanSheets")]
        public double DefenderCleanSheets { get; set; }

        [JsonProperty("GoalkeeperSaves")]
        public double GoalkeeperSaves { get; set; }

        [JsonProperty("GoalkeeperGoalsAgainst")]
        public double GoalkeeperGoalsAgainst { get; set; }

        [JsonProperty("GoalkeeperSingleGoalAgainst")]
        public double GoalkeeperSingleGoalAgainst { get; set; }

        [JsonProperty("GoalkeeperCleanSheets")]
        public double GoalkeeperCleanSheets { get; set; }

        [JsonProperty("GoalkeeperWins")]
        public double GoalkeeperWins { get; set; }

        [JsonProperty("PenaltyKickGoals")]
        public long PenaltyKickGoals { get; set; }

        [JsonProperty("PenaltyKickMisses")]
        public long PenaltyKickMisses { get; set; }

        [JsonProperty("PenaltyKickSaves")]
        public long PenaltyKickSaves { get; set; }

        [JsonProperty("PenaltiesWon")]
        public long PenaltiesWon { get; set; }

        [JsonProperty("PenaltiesConceded")]
        public long PenaltiesConceded { get; set; }

        [JsonProperty("Score")]
        public double Score { get; set; }

        [JsonProperty("OpponentScore")]
        public double OpponentScore { get; set; }
    }

    public enum DraftKingsPosition { Scrambled };

    public enum HomeOrAway { Away, Home };

    public enum Opponent { Ars, Eve, Ful, Lee, Lei, Liv, She, Whu };

    public enum Position { A, D, Gk, M };

    public partial class PlayerSalary2
    {
        public static PlayerSalary2[] FromJson(string json) => JsonConvert.DeserializeObject<PlayerSalary2[]>(json, QuickTypeSalary2.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this PlayerSalary2[] self) => JsonConvert.SerializeObject(self, QuickTypeSalary2.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DraftKingsPositionConverter.Singleton,
                HomeOrAwayConverter.Singleton,
                OpponentConverter.Singleton,
                PositionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DraftKingsPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DraftKingsPosition) || t == typeof(DraftKingsPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Scrambled")
            {
                return DraftKingsPosition.Scrambled;
            }
            throw new Exception("Cannot unmarshal type DraftKingsPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DraftKingsPosition)untypedValue;
            if (value == DraftKingsPosition.Scrambled)
            {
                serializer.Serialize(writer, "Scrambled");
                return;
            }
            throw new Exception("Cannot marshal type DraftKingsPosition");
        }

        public static readonly DraftKingsPositionConverter Singleton = new DraftKingsPositionConverter();
    }

    internal class HomeOrAwayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HomeOrAway) || t == typeof(HomeOrAway?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AWAY":
                    return HomeOrAway.Away;
                case "HOME":
                    return HomeOrAway.Home;
            }
            throw new Exception("Cannot unmarshal type HomeOrAway");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HomeOrAway)untypedValue;
            switch (value)
            {
                case HomeOrAway.Away:
                    serializer.Serialize(writer, "AWAY");
                    return;
                case HomeOrAway.Home:
                    serializer.Serialize(writer, "HOME");
                    return;
            }
            throw new Exception("Cannot marshal type HomeOrAway");
        }

        public static readonly HomeOrAwayConverter Singleton = new HomeOrAwayConverter();
    }

    internal class OpponentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Opponent) || t == typeof(Opponent?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ARS":
                    return Opponent.Ars;
                case "EVE":
                    return Opponent.Eve;
                case "FUL":
                    return Opponent.Ful;
                case "LEE":
                    return Opponent.Lee;
                case "LEI":
                    return Opponent.Lei;
                case "LIV":
                    return Opponent.Liv;
                case "SHE":
                    return Opponent.She;
                case "WHU":
                    return Opponent.Whu;
            }
            throw new Exception("Cannot unmarshal type Opponent");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Opponent)untypedValue;
            switch (value)
            {
                case Opponent.Ars:
                    serializer.Serialize(writer, "ARS");
                    return;
                case Opponent.Eve:
                    serializer.Serialize(writer, "EVE");
                    return;
                case Opponent.Ful:
                    serializer.Serialize(writer, "FUL");
                    return;
                case Opponent.Lee:
                    serializer.Serialize(writer, "LEE");
                    return;
                case Opponent.Lei:
                    serializer.Serialize(writer, "LEI");
                    return;
                case Opponent.Liv:
                    serializer.Serialize(writer, "LIV");
                    return;
                case Opponent.She:
                    serializer.Serialize(writer, "SHE");
                    return;
                case Opponent.Whu:
                    serializer.Serialize(writer, "WHU");
                    return;
            }
            throw new Exception("Cannot marshal type Opponent");
        }

        public static readonly OpponentConverter Singleton = new OpponentConverter();
    }

    internal class PositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Position) || t == typeof(Position?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "A":
                    return Position.A;
                case "D":
                    return Position.D;
                case "GK":
                    return Position.Gk;
                case "M":
                    return Position.M;
            }
            throw new Exception("Cannot unmarshal type Position");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Position)untypedValue;
            switch (value)
            {
                case Position.A:
                    serializer.Serialize(writer, "A");
                    return;
                case Position.D:
                    serializer.Serialize(writer, "D");
                    return;
                case Position.Gk:
                    serializer.Serialize(writer, "GK");
                    return;
                case Position.M:
                    serializer.Serialize(writer, "M");
                    return;
            }
            throw new Exception("Cannot marshal type Position");
        }

        public static readonly PositionConverter Singleton = new PositionConverter();
    }
}
