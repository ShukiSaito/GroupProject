// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickTypePosition;
//
//    var playerPosition = PlayerPosition.FromJson(jsonString);

namespace QuickTypePosition
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class PlayerPosition
    {
        [JsonProperty("PlayerId")]
        public long PlayerId { get; set; }

        [JsonProperty("FirstName")]
        public string FirstName { get; set; }

        [JsonProperty("LastName")]
        public string LastName { get; set; }

        [JsonProperty("CommonName")]
        public string CommonName { get; set; }

        [JsonProperty("ShortName")]
        public string ShortName { get; set; }

        [JsonProperty("Position")]
        public Position Position { get; set; }

        [JsonProperty("PositionCategory")]
        public Position PositionCategory { get; set; }

        [JsonProperty("Jersey")]
        public long Jersey { get; set; }

        [JsonProperty("Foot")]
        public Foot? Foot { get; set; }

        [JsonProperty("Height")]
        public long? Height { get; set; }

        [JsonProperty("Weight")]
        public long? Weight { get; set; }

        [JsonProperty("Gender")]
        public Gender Gender { get; set; }

        [JsonProperty("BirthDate")]
        public DateTimeOffset BirthDate { get; set; }

        [JsonProperty("BirthCity")]
        public string BirthCity { get; set; }

        [JsonProperty("BirthCountry")]
        public string BirthCountry { get; set; }

        [JsonProperty("Nationality")]
        public string Nationality { get; set; }

        [JsonProperty("InjuryStatus")]
        public Injury InjuryStatus { get; set; }

        [JsonProperty("InjuryBodyPart")]
        public Injury InjuryBodyPart { get; set; }

        [JsonProperty("InjuryNotes")]
        public Injury InjuryNotes { get; set; }

        [JsonProperty("InjuryStartDate")]
        public DateTimeOffset? InjuryStartDate { get; set; }

        [JsonProperty("Updated")]
        public DateTimeOffset Updated { get; set; }

        [JsonProperty("PhotoUrl")]
        public Uri PhotoUrl { get; set; }

        [JsonProperty("RotoWirePlayerID")]
        public long? RotoWirePlayerId { get; set; }

        [JsonProperty("DraftKingsPosition")]
        public Position? DraftKingsPosition { get; set; }

        [JsonProperty("UsaTodayPlayerID")]
        public long? UsaTodayPlayerId { get; set; }

        [JsonProperty("UsaTodayHeadshotUrl")]
        public Uri UsaTodayHeadshotUrl { get; set; }

        [JsonProperty("UsaTodayHeadshotNoBackgroundUrl")]
        public object UsaTodayHeadshotNoBackgroundUrl { get; set; }

        [JsonProperty("UsaTodayHeadshotUpdated")]
        public DateTimeOffset? UsaTodayHeadshotUpdated { get; set; }

        [JsonProperty("UsaTodayHeadshotNoBackgroundUpdated")]
        public object UsaTodayHeadshotNoBackgroundUpdated { get; set; }
    }

    public enum Position { A, D, F, Gk, M, MF };

    public enum Foot { Both, Left, Right };

    public enum Gender { Male };

    public enum Injury { Scrambled };

    public partial class PlayerPosition
    {
        public static PlayerPosition[] FromJson(string json) => JsonConvert.DeserializeObject<PlayerPosition[]>(json, QuickTypePosition.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this PlayerPosition[] self) => JsonConvert.SerializeObject(self, QuickTypePosition.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                PositionConverter.Singleton,
                FootConverter.Singleton,
                GenderConverter.Singleton,
                InjuryConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Position) || t == typeof(Position?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "A":
                    return Position.A;
                case "D":
                    return Position.D;
                case "F":
                    return Position.F;
                case "GK":
                    return Position.Gk;
                case "M":
                    return Position.M;
                case "M/F":
                    return Position.MF;
            }
            throw new Exception("Cannot unmarshal type Position");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Position)untypedValue;
            switch (value)
            {
                case Position.A:
                    serializer.Serialize(writer, "A");
                    return;
                case Position.D:
                    serializer.Serialize(writer, "D");
                    return;
                case Position.F:
                    serializer.Serialize(writer, "F");
                    return;
                case Position.Gk:
                    serializer.Serialize(writer, "GK");
                    return;
                case Position.M:
                    serializer.Serialize(writer, "M");
                    return;
                case Position.MF:
                    serializer.Serialize(writer, "M/F");
                    return;
            }
            throw new Exception("Cannot marshal type Position");
        }

        public static readonly PositionConverter Singleton = new PositionConverter();
    }

    internal class FootConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Foot) || t == typeof(Foot?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Both":
                    return Foot.Both;
                case "Left":
                    return Foot.Left;
                case "Right":
                    return Foot.Right;
            }
            throw new Exception("Cannot unmarshal type Foot");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Foot)untypedValue;
            switch (value)
            {
                case Foot.Both:
                    serializer.Serialize(writer, "Both");
                    return;
                case Foot.Left:
                    serializer.Serialize(writer, "Left");
                    return;
                case Foot.Right:
                    serializer.Serialize(writer, "Right");
                    return;
            }
            throw new Exception("Cannot marshal type Foot");
        }

        public static readonly FootConverter Singleton = new FootConverter();
    }

    internal class GenderConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Gender) || t == typeof(Gender?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Male")
            {
                return Gender.Male;
            }
            throw new Exception("Cannot unmarshal type Gender");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Gender)untypedValue;
            if (value == Gender.Male)
            {
                serializer.Serialize(writer, "Male");
                return;
            }
            throw new Exception("Cannot marshal type Gender");
        }

        public static readonly GenderConverter Singleton = new GenderConverter();
    }

    internal class InjuryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Injury) || t == typeof(Injury?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Scrambled")
            {
                return Injury.Scrambled;
            }
            throw new Exception("Cannot unmarshal type Injury");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Injury)untypedValue;
            if (value == Injury.Scrambled)
            {
                serializer.Serialize(writer, "Scrambled");
                return;
            }
            throw new Exception("Cannot marshal type Injury");
        }

        public static readonly InjuryConverter Singleton = new InjuryConverter();
    }
}
